Function take (takes the first x elements) and
function drop (drops the first 2 elements)

let rec take x l = 
if x = 0 then [] else
match l with
h::t -> h :: take (x-1) t;;

let rec drop x l =
if x = 0 then l else
match l with
h::t -> drop (x-1) t;;

merge (mine is better than the book apparently)

let rec merge l1 l2 = 
match l1, l2 with
[],l -> l
| l,[] -> l
| h1::t1, h2::t2 -> 
if h1 <= h2 then (h1 :: merge t1 l2)
else (h2 :: merge t2 l1);;

(we need length first):

let rec length_inner l n =
match l with
[] -> n 
| h::t -> length_inner t (n + 1);;

let length l = length_inner l 0;;

so, this is MY msort but p much the same

let rec msort l =
match l with
[] -> []
| [x] -> [x]
| h::t -> let left = take ((length l) / 2) l in
          let right = drop ((length l) / 2) l in
          merge (msort left) (msort right);;


1.
let rec msort l =
match l with
[] -> []
| [x] -> [x]
| h::t -> let len_msort = ((length l) / 2) in 
          let left = take len_msort l in
          let right = drop len_msort l in
          merge (msort left) (msort right);;

2.
Take and Drop will fail if x is greater than the size of the list.
However, we're always taking x as the length of msort divided by two, 
therefore it can never be the case that take and drop will fail.

3.
Keep isort the same, just change the insert function

let rec insert x l =
match l with
[] -> [x]
| h::t ->
if x<=h then h :: (insert x t) else x::h::t;;

4.
let rec is_sorted l = 
match l with
[] -> true
| [x] -> true
| h::x::t -> if (h <= x) then is_sorted (x::t) else false;; 
